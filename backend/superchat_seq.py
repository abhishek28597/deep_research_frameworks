"""Super Chat Sequential Mode - Council followed by DxO refinement."""

from typing import List, Dict, Any, Tuple
from .council import run_full_council
from .DxO import (
    stage1_lead_research,
    stage2_critic_analysis,
    stage3_domain_expertise,
    stage4_aggregate_synthesis
)
from .groq_client import query_model
from .config import LEAD_RESEARCH_MODEL, CRITIC_MODEL, DOMAIN_EXPERT_MODEL, AGGREGATOR_MODEL


async def run_sequential_superchat(user_query: str) -> Tuple[List, List, Dict, Dict, Dict, Dict, Dict]:
    """
    Run sequential Super Chat: Council â†’ DxO (refining Council result).
    
    Args:
        user_query: The user's research question
        
    Returns:
        Tuple of (council_stage1, council_stage2, council_stage3, 
                 dxo_stage1, dxo_stage2, dxo_stage3, dxo_stage4)
    """
    # Step 1: Run full Council process
    council_stage1, council_stage2, council_stage3, council_metadata = await run_full_council(user_query)
    
    # If Council failed, return early with error
    if not council_stage1 or council_stage3.get('response', '').startswith('Error:'):
        return council_stage1, council_stage2, council_stage3, {}, {}, {}, {
            "model": "error",
            "response": "Council process failed. Please try again."
        }
    
    # Step 2: Run DxO stages with Council context
    # Stage 1: Lead Research - refine Council result and eliminate wrong facts
    dxo_stage1 = await stage1_lead_research_with_council(
        user_query,
        council_stage3
    )
    
    if dxo_stage1.get('response', '').startswith("Error:"):
        return council_stage1, council_stage2, council_stage3, dxo_stage1, {}, {}, {
            "model": "error",
            "response": "Lead Research agent failed. Please try again."
        }
    
    # Stage 2: Critic - analyze both Council result and Lead Research findings
    dxo_stage2 = await stage2_critic_analysis_with_council(
        user_query,
        council_stage3,
        dxo_stage1
    )
    
    # Stage 3: Domain Expert - provide expertise on both
    dxo_stage3 = await stage3_domain_expertise_with_council(
        user_query,
        council_stage3,
        dxo_stage1,
        dxo_stage2
    )
    
    # Stage 4: Aggregator - synthesize final answer from all inputs
    dxo_stage4 = await stage4_aggregate_synthesis_with_council(
        user_query,
        council_stage3,
        dxo_stage1,
        dxo_stage2,
        dxo_stage3
    )
    
    return council_stage1, council_stage2, council_stage3, dxo_stage1, dxo_stage2, dxo_stage3, dxo_stage4


async def stage1_lead_research_with_council(
    user_query: str,
    council_result: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Stage 1: Lead Research agent refines Council result and eliminates wrong facts.
    
    Args:
        user_query: The original user query
        council_result: Council's final synthesized answer (stage3)
        
    Returns:
        Dict with 'model' and 'response' keys
    """
    research_prompt = f"""You are a Lead Research Agent specializing in breadth-first research and fact-checking.
Your task is to refine and improve an answer that was generated by a Council of AI models.

Original Question: {user_query}

Council's Synthesized Answer:
{council_result.get('response', '')}

Your task is to:
1. Review the Council's answer for accuracy and completeness
2. Identify any wrong facts, inaccuracies, or misleading information
3. Research missing points or areas that need more depth
4. Eliminate extra or irrelevant pointers
5. Identify gaps in the Council's response
6. Provide a refined research report that corrects errors and fills gaps

Focus on:
- Fact-checking and eliminating incorrect information
- Adding missing important points
- Removing unnecessary or irrelevant details
- Ensuring comprehensive coverage of the topic

Provide your refined research findings:"""

    messages = [{"role": "user", "content": research_prompt}]

    response = await query_model(LEAD_RESEARCH_MODEL, messages, max_completion_tokens=3000)

    if response is None:
        return {
            "model": LEAD_RESEARCH_MODEL,
            "response": "Error: Lead Research agent failed to respond."
        }

    return {
        "model": LEAD_RESEARCH_MODEL,
        "response": response.get('content', '')
    }


async def stage2_critic_analysis_with_council(
    user_query: str,
    council_result: Dict[str, Any],
    research_result: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Stage 2: Critic agent analyzes Council result and Lead Research findings.
    
    Args:
        user_query: The original user query
        council_result: Council's final synthesized answer
        research_result: Lead Research findings
        
    Returns:
        Dict with 'model' and 'response' keys containing critique
    """
    critique_prompt = f"""You are a Critic Agent with expertise in critical analysis and evaluation.
Your task is to critically evaluate both the Council's answer and the Lead Research agent's refinements.

Original Question: {user_query}

Council's Synthesized Answer:
{council_result.get('response', '')}

Lead Research Agent's Refined Findings:
{research_result.get('response', '')}

Your critical analysis should:
1. Evaluate the quality and accuracy of both the Council's answer and the Lead Research refinements
2. Identify strengths and weaknesses in both responses
3. Point out any remaining gaps, missing perspectives, or overlooked aspects
4. Assess whether the Lead Research agent successfully identified and corrected errors
5. Evaluate the comprehensiveness and depth of both responses
6. Highlight any potential biases, assumptions, or limitations
7. Suggest areas that still need further investigation or clarification
8. Assess the reliability and validity of the findings

Provide a thorough critical analysis:"""

    messages = [{"role": "user", "content": critique_prompt}]

    response = await query_model(CRITIC_MODEL, messages, max_completion_tokens=2000)

    if response is None:
        return {
            "model": CRITIC_MODEL,
            "response": "Error: Critic agent failed to respond."
        }

    return {
        "model": CRITIC_MODEL,
        "response": response.get('content', '')
    }


async def stage3_domain_expertise_with_council(
    user_query: str,
    council_result: Dict[str, Any],
    research_result: Dict[str, Any],
    critique_result: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Stage 3: Domain Expert provides specialized expertise on Council and research findings.
    
    Args:
        user_query: The original user query
        council_result: Council's final synthesized answer
        research_result: Lead Research findings
        critique_result: Critic analysis
        
    Returns:
        Dict with 'model' and 'response' keys containing domain expertise
    """
    expert_prompt = f"""You are a Domain Expert Agent with deep specialized knowledge in relevant domains.
Your task is to provide expert insights and domain-specific expertise on the following question.

Original Question: {user_query}

Council's Synthesized Answer:
{council_result.get('response', '')}

Lead Research Agent's Refined Findings:
{research_result.get('response', '')}

Critical Analysis:
{critique_result.get('response', '')}

Your domain expertise should:
1. Provide specialized knowledge and insights relevant to the question
2. Apply domain-specific frameworks, methodologies, or best practices
3. Address the gaps and concerns raised in the critical analysis
4. Offer expert recommendations based on your domain knowledge
5. Consider practical implications and real-world applications
6. Integrate your expertise with both the Council's answer and the Lead Research findings
7. Validate or challenge specific claims based on your domain expertise

Provide your expert analysis and recommendations:"""

    messages = [{"role": "user", "content": expert_prompt}]

    response = await query_model(DOMAIN_EXPERT_MODEL, messages, max_completion_tokens=2000)

    if response is None:
        return {
            "model": DOMAIN_EXPERT_MODEL,
            "response": "Error: Domain Expert agent failed to respond."
        }

    return {
        "model": DOMAIN_EXPERT_MODEL,
        "response": response.get('content', '')
    }


async def stage4_aggregate_synthesis_with_council(
    user_query: str,
    council_result: Dict[str, Any],
    research_result: Dict[str, Any],
    critique_result: Dict[str, Any],
    expert_result: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Stage 4: Aggregator synthesizes all inputs into final response.
    
    Args:
        user_query: The original user query
        council_result: Council's final synthesized answer
        research_result: Lead Research findings
        critique_result: Critic analysis
        expert_result: Domain expertise
        
    Returns:
        Dict with 'model' and 'response' keys containing final synthesis
    """
    synthesis_prompt = f"""You are an Aggregator Agent responsible for synthesizing multiple expert inputs into a coherent, comprehensive final answer.

Original Question: {user_query}

COUNCIL'S SYNTHESIZED ANSWER:
{council_result.get('response', '')}

STAGE 1 - Lead Research Refinements:
{research_result.get('response', '')}

STAGE 2 - Critical Analysis:
{critique_result.get('response', '')}

STAGE 3 - Domain Expert Insights:
{expert_result.get('response', '')}

Your task as Aggregator is to:
1. Synthesize all inputs into a unified, comprehensive answer
2. Integrate the Council's answer with the Lead Research refinements, critical insights, and domain expertise
3. Address the original question with the full context from all stages
4. Resolve any contradictions or conflicts between different perspectives
5. Create a clear, well-structured final response that leverages all inputs
6. Ensure the final answer is accurate, complete, and actionable
7. Eliminate any wrong facts that were identified
8. Incorporate missing points that were discovered
9. Remove any unnecessary or irrelevant information

Provide your synthesized final answer that represents the best of all inputs:"""

    messages = [{"role": "user", "content": synthesis_prompt}]

    response = await query_model(AGGREGATOR_MODEL, messages, max_completion_tokens=4000)

    if response is None:
        return {
            "model": AGGREGATOR_MODEL,
            "response": "Error: Aggregator agent failed to synthesize final response."
        }

    return {
        "model": AGGREGATOR_MODEL,
        "response": response.get('content', '')
    }

